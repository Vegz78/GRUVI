<?php

/*  Random URL image file list generator for the Image Viewer app on the Squeezebox Touch, Radio etc. with:
	-Random selection of files and random shuffle of the lists between every call to this PHP-file on
	 independent web servers, or with periodic scheduled jobs on the LMS internal web server.
	-Locally cached copies of the images with reduced sizes to fit the respective players and
	 to minimize load on the Lyrion/LMS server, players and network
	-Image files hosted on a web server of your chosing and fittet to the players' screen sizes
	-Choice between images with or without capitons generated by file and folder names
	-Choice of number of cached files and expiry time for reload of new batches of random images
	-Added support for multiple image folders with internal distribution weighing for the random image selection
	 and with the choice between serial and parallel processing of the ImageMagick conversions of image folders
	-Added support for bmp, cr2, gif, heic, png, tiff and webp in addition to jpeg, new ability to run on
	 Windows in addition to Linux and MacOS, improved file handling and extended command line options

	Choice between total independence from LMS on any web server, or to run on the LMS internal web server.

	No more versions or plugins conflicts, no more spinning
	disks on the NAS, heavy machinery required to run 24/7 etc... ;-)


	Feel free to copy and improve as you feel fit! I did so much research and copying myself,
	that I don't remember all the people I should be thanking.

	!! Special thanks to the primus motors on the Squeezebox community forum who keeps both the
	best audio community and the best music server/player ecosystem ever still alive and kicking!!

	Nice also if any suggestions for improvements to this script were posted back on this forum thread
	or on https://github.com/Vegz78/GRUVI!
	I'm on the forum from time to time, but don't have the resources to provide any reliable support.


	by vegz78...

	Originally posted in this Squeezebox forum thread:
	https://forums.slimdevices.com/showthread.php?108498-Announce-GRUVI-generate-random-URLs_for-viewing-images
*/


//GLOBAL SETTINGS
$LIST_SIZE = 60; 				//Number of random images to be processed and included in the image URL list
$FILE_AGE_MAX = 2880;			//Time in minutes before images in the $IMAGES_ROOT folder are overwritten
$RANDOMIZE = True;				//True = Random order of images, False = Original order of search result
$CAPTIONS = True;				//True = Captions ON, False = Captions OFF
$GRUVI_LOGO = True;				//True = GRUVI logo as first image = ON, False = GRUVI logo OFF
$IMG_SOURCE = array("//Path_to/_image_folder1", "C:/Path_to_/image_folder2"); //Paths with forward slashes to one or more image folders
								//always forward slashes, also on WIndows, and no trailing slashes
$SOURCE_WEIGHT = array(0.3, 0.7);	//Relative weights between the above chosen image folders. There must be as many 
								//weights as the number of folders in the $IMG_SOURCE above and add up to 1 exactly
$URL_ROOT = 'http://192.168.x.y:9000/html/'; 	//Host web server address on the internal LMS web server
//$URL_ROOT = 'http://192.168.x.y/';	//Host web server address on most independent web servers
$IMAGE_ROOT = 'gruvi_img';		//Storage folder for converted images in the www-directory
$PARALLEL_CONVERT = True;		//If multiple $IMG_SOURCEs, each can be converted in parallel, but takes a toll on weaker
 								//e.g. RPi servers. True = Parallel conversions, False = Serial conversions
$LINK_TO_ORIGINALS = False; 	//True = Don't make copies, but URLs in list link to the original images, False = Make copies (default)
$CUSTOM_IMAGE_COPIES = False;	//True = Make custom resolution of image copies, False = Adhere to SB Touch and Radio screen sizes
$CUSTOM_WIDTH = 800;  			//Width in pixels for custom image copy sizes
$CUSTOM_HEIGHT = 480;  			//Height in pixels for custom image copy sizes
$WEBLIST = True;				//True = Generate web URL lists (default), False = generate os file path lists
$ALL = False;					//True = $LIST_SIZE is found a posteriori image files search, False = $LIST_SIZE is set a priori image files search

//IMAGE FORMAT SETTINGS																//(Format support between different ImageMagick versions vary,
//Whether to scan for and convert images with the given file extensions or not		// very old versions typically do not support .HEIC and .WEBP)
$BMP = True;
$CR2 = True;
$GIF = True;
$HEIC = True;
$JPEG = True;
$PNG = True;
$TIFF = True;
$WEBP = True;


//Function for running the generated image conversion tasks
function ConvertImages($fp, $doLoop=False, $x=NULL) {
	global $WINDOWS, $IMAGE_ROOT, $BEGIN_NAME, $PARALLEL_CONVERT;
	if (!$WINDOWS) {
		fwrite($fp, 'rm ' . $IMAGE_ROOT . $BEGIN_NAME . $x. PHP_EOL);
		fclose($fp);
		exec('chmod 755 ' . escapeshellarg($IMAGE_ROOT . $BEGIN_NAME . $x));
		exec(escapeshellarg($IMAGE_ROOT . $BEGIN_NAME . $x) . ' >> /dev/null 2>&1 &');
	}else {
		fclose($fp);
		if (!$doLoop) {
			exec("type " . escapeshellarg($IMAGE_ROOT . $BEGIN_NAME) . " | cmd 2>&1");
		}else {
			//Looping through lines in the convert commands file, since Windows pipes with "cmd"
			//does not allow certain special characters even in double quoted commands
			$lines = file($IMAGE_ROOT . $BEGIN_NAME . $x, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES);
			if ($lines !== false) {
				foreach ($lines as $line) {
					$command = ($PARALLEL_CONVERT ? "start /B " : "") . $line . " 2>&1";
					pclose(popen($command, 'r'));
				}
			} else {
				echo "Error: Could not read the file.";
			}
		}
		unlink($IMAGE_ROOT . $BEGIN_NAME  . $x);
	}
}


//Check and set operating system and ImageMagick executable
$WINDOWS = False; $IMAGEMAGICK = "convert";
if (strtoupper(substr(php_uname('s'), 0, 3)) === 'WIN') $WINDOWS = True;
$output = []; $exitCode = 0; @exec("magick -help 2>&1", $output, $exitCode);
if ($exitCode === 0 ) $IMAGEMAGICK = "magick";


//Interpret the arguments list and adjust GLOBAL SETTINGS accordingly
$isTouch = False;
if (PHP_SAPI === 'cli') {	//Only valid for command line, not web
	$help = False;		//Whether to show help screen or not
	$test = False;		//Whether to perforum dryrun or not
	$defaults = True;	//Whether to use default settings from gruvi.php or custom settings from arguments

	//Get command line arguments if there are one or more arguments
	if ($argc > 1) {
		if ($argc == 2 && strtoupper($argv[1]) == "TOUCH") $isTouch = True;
		elseif ($argc == 2 && $argv[1] == "CUST") $CUSTOM_IMAGE_COPIES = True;
		elseif ($argc == 2 && $argv[1] == "DRYRUN") $test = True;
		elseif ($argc == 3 && ($argv[1] == "DRYRUN" || $argv[2] == "DRYRUN")) {
			$test = True;
			if (strtoupper($argv[1]) == "TOUCH" || strtoupper($argv[2]) == "TOUCH") $isTouch = True;
			elseif ($argv[1] == "CUST" || $argv[2] == "CUST") $CUSTOM_IMAGE_COPIES = True;
		}else {
			//Specify default settings when in command line mode
			$WEBLIST = True;
			$RANDOMIZE = False;
			$CAPTIONS = False;
			$PARALLEL_CONVERT = True;
			$LINK_TO_ORIGINALS = True;
			$CUSTOM_IMAGE_COPIES = False;
			$GRUVI_LOGO = False;
			$FILE_AGE_MAX = 0;	//No point in waiting to update images from the command line, except during scheduled tasks with less than 2 arguments (Touch&CUST)
			$defaults = False;
			$directoryCount = 0;

			//Specify settings according to command line arguments given
			foreach($argv as $index => $arg) {
				if ($index > 0) {
					if (!empty($arg) && (realpath($arg) || (substr_compare($arg, __DIR__, 0, strlen(__DIR__))) === 0)) {
						if ($directoryCount < 1) $IMG_SOURCE = array(realpath($arg));
						else array_push($IMG_SOURCE, realpath($arg));
						$directoryCount++;
					}elseif ($arg == ".") {
						if ($directoryCount < 1) $IMG_SOURCE = array(realpath(getcwd()));
						else array_push($IMG_SOURCE, realpath(getcwd()));
						$directoryCount++;
					}
					elseif (preg_match("/^([0-9])+(x)+([0-9])+$/i", $arg)) {
						$CUSTOM_WIDTH = (int)substr($arg, 0, strpos($arg,'x'));
						$CUSTOM_HEIGHT = (int)substr($arg, strpos($arg, 'x') + 1);
						$CUSTOM_IMAGE_COPIES = True;
					}
					elseif ($arg == "FILE") $WEBLIST = False;
					elseif ($arg == "RAND") $RANDOMIZE = True;
					elseif ($arg == "CONV") $LINK_TO_ORIGINALS = False;
					elseif ($arg == "CUST") $CUSTOM_IMAGE_COPIES = True;
					elseif ($arg == "CAPT") $CAPTIONS = True;
					elseif ($arg == "FULL") $ALL = True;
					elseif ($arg == "GRUVI") $GRUVI_LOGO = True;
					elseif ($arg == "DRYRUN") $test = True;
					elseif ($arg == "/?" || $arg == "-h" || $arg == "--help" || $arg == "HELP") $help = True;
					elseif (is_numeric($arg)) $LIST_SIZE = $arg;
					elseif (strtoupper($arg) == "TOUCH") $isTouch = True;
				}
			}
			//Set distribution weights equally to the number of folders given as arguments
			if ($directoryCount > 0) {
				$SOURCE_WEIGHT = array();
				foreach($IMG_SOURCE as $counter) array_push($SOURCE_WEIGHT, 1/$directoryCount);
			}
		}
	}
	//Output of settings before the rest of the execution
	if (!$help) {
		if ($test) echo "****** ONLY A TEST! ******" . PHP_EOL;
		echo "GRUVI SETTINGS" . ($defaults ? " FROM gruvi.php" : " FROM ARGUMENTS") . ":" . PHP_EOL;
		echo "no. of image files: " . (!$ALL ? "max " . $LIST_SIZE : "not known a priori directory scan...") . PHP_EOL;
		echo "converting to thumbnails: " . (!$LINK_TO_ORIGINALS ? "yes" : "no, linking to original image files") . PHP_EOL;
		echo (!$LINK_TO_ORIGINALS ? "image save folder: " . $IMAGE_ROOT . PHP_EOL : "");
		if ($LINK_TO_ORIGINALS || $ALL || $CUSTOM_IMAGE_COPIES) $FILE_NAME = 'gruvi.txt';
		elseif ($isTouch) $FILE_NAME = 'sbtouch.txt';
		else $FILE_NAME = 'sbradio.txt';
		echo "image list output file: " . $FILE_NAME . PHP_EOL;
		echo "directories scanned:" . PHP_EOL;
		foreach($IMG_SOURCE as $index => $dir) echo ($index + 1 . ": " . $dir . (!($LINK_TO_ORIGINALS || $ALL) ? "(weight: " . round($SOURCE_WEIGHT[$index], 2) . ")" : "") . PHP_EOL);
		echo "webserver root: " . $URL_ROOT . PHP_EOL;
		echo "randomize: " . ($RANDOMIZE ? "yes" : "no") . PHP_EOL;
		echo "captions: " . ($CAPTIONS ? "yes" : "no") . PHP_EOL;
		echo "list type: " . ($WEBLIST ? "url" : "file") . PHP_EOL;
		echo "GRUVI logo: " . ($GRUVI_LOGO ? "yes" : "no") . PHP_EOL;
		echo "file age before update: " . $FILE_AGE_MAX . "min" . PHP_EOL;
		echo "custom dimensions: " . ($CUSTOM_IMAGE_COPIES ? "yes" : "no") . PHP_EOL;
		echo "width: " . ($CUSTOM_IMAGE_COPIES ? $CUSTOM_WIDTH : ($isTouch ? "480" : "320")) . PHP_EOL;
		echo "height: " . ($CUSTOM_IMAGE_COPIES ? $CUSTOM_HEIGHT : ($isTouch ? "272" : "240")) . PHP_EOL;
		echo "image format support: " . ($BMP ? "BMP ":"") . ($CR2 ? "CR2 ":"") . ($GIF ? "GIF ":"") . ($HEIC ? "HEIC ":"") . ($JPEG ? "JPEG ":"") . ($PNG ? "PNG ":"") . ($TIFF ? "TIFF ":"") . ($WEBP ? "WEBP ":"") . PHP_EOL;
		if ($test) {
			echo "****** ONLY A TEST! ******" . PHP_EOL;
			exit(0);
		}
	//The help screen output
	}else{
		echo "INTRODUCTION:" . PHP_EOL;
		echo "gruvi.php functions as a command line tool to fairly quickly produce lists of file" . PHP_EOL;
		echo "paths or URL-links to images from a selection of folders and their subfolders" . PHP_EOL;
		echo "Or to convert the images in similar folder selections to copies in the default" . PHP_EOL;
		echo "gruvi_img folder in the working directory of the script, with corresponding lists" . PHP_EOL;
		echo "of file paths or URL-links (LMS default) to these copies." . PHP_EOL . PHP_EOL;
		echo "GRUVI USAGE:" . PHP_EOL;
		echo "php gruvi.php ARG1, ARG2, ... , ARGN       -Often needs sudo in front for permissions" . PHP_EOL . PHP_EOL;
		echo "Example:" . PHP_EOL;
		echo "php gruvi.php . RAND CONV 50               -Find and convert 50 random images from the" . PHP_EOL;
		echo "                                            current folder including subfolders" . PHP_EOL . PHP_EOL;
		if ($WINDOWS) passthru('pause');
		else @trim(shell_exec("read -p 'Press ENTER to continue...' id\\necho \\NULL"));
		echo PHP_EOL . PHP_EOL;
		echo "COMMAND LINE ARGUMENTS:" . PHP_EOL;
		echo "(Default argument values can be omitted)" . PHP_EOL;
		echo "FOLDER1, FOLDER2, ... , FOLDERN            -Folders where GRUVI should look for images to" . PHP_EOL;
		echo "                                            convert (EMPTY = use settings inside gruvi.php)" . PHP_EOL;
		echo "NUMBER, e.g. 50                            -NUMBER = The no. of image files to pick, e.g. 50" . PHP_EOL;
		echo "FULL                                       -FULL = Make list as big as the number of files" . PHP_EOL;
		echo "                                            actually found, instead of a preset selection" . PHP_EOL;
		echo "                                            size from the NUMBER argument or the $LIST_SIZE" . PHP_EOL;
		echo "                                            setting inside gruvi.php" . PHP_EOL;
		echo "FILE|URL (default)                         -FILE = Make list as folder paths" . PHP_EOL;
		echo "                                            URL = Make list of images as web urls with" . PHP_EOL;
		echo "                                            server address inside gruvi.php as root" . PHP_EOL;
		echo "RAND|SORT (default)                        -RAND = Shuffle the list," . PHP_EOL;
		echo "                                            SORT = Present list as found in the scanned" . PHP_EOL;
		echo "                                            directory tree" . PHP_EOL;
		echo "CONV|LINK (default)                        -CONV = Make converted copies of images to the" . PHP_EOL;
		echo "                                            folder specified in gruvi.php(default: gruvi_img)" . PHP_EOL;
		echo "                                            linked to in the file sbradio.txt," . PHP_EOL;
		echo "                                            LINK = Only link to the found files, no" . PHP_EOL;
		echo "                                            conversions and links found in the file" . PHP_EOL;
		echo "                                            gruvi.txt" . PHP_EOL;
		echo "GRUVI|NOLOGO (default)                     -GRUVI = Add extra image file with the GRUVI logo" . PHP_EOL;
		echo "                                            NOLOGO = Do not at GRUVI logo image file" . PHP_EOL;
		echo "CAPT|NOCAP (default)                       -CAPT = Add image caption of file and folder names" . PHP_EOL;
		echo "                                            NOCAP = Do not add captions" . PHP_EOL;
		echo "CUST|STND (default)                        -CUST = Make image copies of custom dimensions" . PHP_EOL;
		echo "                                            STND = Standard dimension 320x240" . PHP_EOL;
		echo "CUSTOM DIMENSION e.g. 1280x720             -Custom image copy dimension as width x height" . PHP_EOL;
		echo "DRYRUN                                     -DRYRUN = Stop before execution, showing settings" . PHP_EOL;
		echo "HELP (or /? or -h or --help)               -HELP = Show this help screen" . PHP_EOL . PHP_EOL;
		if ($WINDOWS) passthru('pause');
		else @trim(shell_exec("read -p 'Press ENTER to continue...' id\\necho \\NULL"));
		echo PHP_EOL . PHP_EOL;
		echo "SPECIAL CASES AND FOR LMS:" . PHP_EOL;
		echo "gruvi.php should work on any webserver with PHP support and when called directly from either" . PHP_EOL;
		echo "any webbrowser or any LMS player with a screen to display images. gruvi.php identifies the" . PHP_EOL;
		echo "SB Radio or Touch players automatically based on the HTTP_USER_AGENT provided by the" . PHP_EOL;
		echo "Image Viewer application and adjusts the corresponding image dimensions accordingly to show" . PHP_EOL;
		echo "correctly on their screens. Additional adjustments to settings in the gruvi.php script files" . PHP_EOL;
		echo "itself can be made to accomodate other players and screen sizes. " . PHP_EOL . PHP_EOL;
		echo "php gruvi.php                              -Produces images for the Squeezebox Radio with" . PHP_EOL;
		echo "                                            settings set inside the gruvi.php script file" . PHP_EOL;
		echo "php gruvi.php Touch or CUST                -Produces images for the Touch or custom player" . PHP_EOL;
		echo "                                            with settings inside the gruvi.php script file" . PHP_EOL . PHP_EOL;
		echo "In a webbrowser / The SB player's Image Viewer source specific settings" . PHP_EOL;
		echo "(replace with webserver's true IP address and root folder):" . PHP_EOL;
		echo "http://192.168.x.y/gruvi.php               -Produces image list directly with images for the" . PHP_EOL;
		echo "                                            SB Radio with settings set inside the gruvi.php" . PHP_EOL;
		echo "                                            script file" . PHP_EOL;
		echo "http://192.168.x.y/gruvi.php?player=Touch  -Produces image list directly with images for the" . PHP_EOL;
		echo "                                            SB Touch with settings set inside the gruvi.php" . PHP_EOL;
		echo "http://192.168.x.y/gruvi.php?player=Custom -Produces image list directly with images for a" . PHP_EOL;
		echo "                                            custom player, e.g. the O2 Joggler 800x480, with" . PHP_EOL;
		echo "                                            custom settings inside the gruvi.php script file" . PHP_EOL . PHP_EOL;
		echo "For the Lyrion/Logitech/Squeezebox Music Server's built in webserver" . PHP_EOL;
		echo "(replace with the LMS' true IP address):" . PHP_EOL;
		echo "http://192.168.x.y:9000/html/sbradio.txt   -Image list directly to images for the SB Radio" . PHP_EOL;
		echo "                                            with settings set inside the gruvi.php script" . PHP_EOL;
		echo "http://192.168.0.1:9000/html/sbtouch.txt   -Image list directly for the Touch or a custom " . PHP_EOL;
		echo "http://192.168.0.1:9000/html/gruvi.txt      player with settings inside the gruvi.php script" . PHP_EOL . PHP_EOL;
		echo "Since the LMS internal webserver does not support PHP, the images pointed to in the lists" . PHP_EOL;
		echo "must be produced by a scheduled task on the computer running LMS." . PHP_EOL . PHP_EOL;
		exit(0);
	}
}else {
	//Read and handle webargument
	$webarg = $_GET['player'];
	if ($webarg == 'Touch') $isTouch = True;
	elseif ($webarg == 'Custom') $CUSTOM_IMAGE_COPIES = True;
}


//Suppress errors and warning displaying to http
error_reporting(0); ini_set('display_errors', 'Off');


//Clean up paths
if (!is_dir($IMAGE_ROOT)) {
	if (@mkdir($IMAGE_ROOT)) {
	}else {
		exit("Did not succeed in finding and creating the gruvi_img folder.");
	}
}
$IMAGE_ROOT_UNMODIFIED = $IMAGE_ROOT;
$IMAGE_ROOT = realpath($IMAGE_ROOT) . DIRECTORY_SEPARATOR;
foreach($IMG_SOURCE as $source) $source = realpath($source);
$lockFolder = $IMAGE_ROOT . 'gruvi.lock';


//Check consistency between number of sources and weights, exit otherwise
$noOfSources = count($IMG_SOURCE);
$noOfWeights = count($SOURCE_WEIGHT);
$thousandsWeights = array();
foreach($SOURCE_WEIGHT as $weight){
	array_push($thousandsWeights, round($weight*1000,0));
}
$sumOfWeights = array_sum($thousandsWeights);
if (1000 - $sumOfWeights == -1) $sumOfWeights--;
if (1000 - $sumOfWeights == 1) $sumOfWeights++;
if ($noOfSources != $noOfWeights || $sumOfWeights != 1000) {
	exit("Inconsistency between number of sources and weights.\n");
}


//Setup and change of control flow for linking to originals
if ($LINK_TO_ORIGINALS) {
	$CAPTIONS = False;
	$GRUVI_LOGO = False;
	if (!$ALL) goto link_to_originals1;
}


//Identify player type and set corresponding player specific variables
$FILE_NAME = ($CUSTOM_IMAGE_COPIES) ? 'gruvi.txt' : 'sbradio.txt';
$FILE_SUFFIX = ($CUSTOM_IMAGE_COPIES) ? '_custom.jpg' : '.jpg';
$BEGIN_NAME = ($CUSTOM_IMAGE_COPIES) ? '.custom_start' : '.radio_start';
$X_WIDTH = ($CUSTOM_IMAGE_COPIES) ? $CUSTOM_WIDTH : 320;
$Y_HEIGHT = ($CUSTOM_IMAGE_COPIES) ? $CUSTOM_HEIGHT : 240;
$C_HEIGHT = ($CUSTOM_IMAGE_COPIES) ? floor($Y_HEIGHT * 22/240) : 22;
$P_SIZE = ($CUSTOM_IMAGE_COPIES) ? floor($Y_HEIGHT * 10/240) : 10;
if((isset($_SERVER['HTTP_USER_AGENT']) || $isTouch) && !$CUSTOM_IMAGE_COPIES) {
	if($isTouch) {
		$playerType = "fab4";
	} elseif(isset($_SERVER['HTTP_USER_AGENT'])) {
		$playerType = $_SERVER['HTTP_USER_AGENT']; //Identifier for the different player types
	}
	if (strpos($playerType, 'fab4') !== false) {
		$isTouch = True; //TRUE if Squeezebox Touch, FALSE otherwise
		$FILE_NAME = 'sbtouch.txt'; //URL list file name for the Touch
		$FILE_SUFFIX = '_fab4.jpg'; //Image file suffix for the Touch
		$BEGIN_NAME = '.touch_start';
		$X_WIDTH = 480;
		$Y_HEIGHT = 272;
		$C_HEIGHT = 25;
		$P_SIZE = 11;
	}
}


//Check whether the lock file has not been cleanly deleted on any previous runs,
// perhaps by an interrupted run
if (is_dir($lockFolder) && (time() - @filemtime($lockFolder))/60 > 1) {
	rmdir($lockFolder);
}


//Change control flow for getting the list size after the image files
//are scanned and found, when all image files found are desired.
if ($ALL && !$LINK_TO_ORIGINALS) goto all1;
if ($ALL && $LINK_TO_ORIGINALS) goto link_to_originals2;
all2:
if ($ALL) $LIST_SIZE = count($fileArray);


//IMAGE FILE OPERATIONS
//Delete superflous files
//List new files to be written
$newFileNames = array();
$filesDeleted = 0;
for ($i = 1; $i <= $LIST_SIZE; $i++) {
	array_push($newFileNames, $i . $FILE_SUFFIX);
}
//Query $IMAGE_ROOT folder contents
$directoryContents = scandir($IMAGE_ROOT);
//Filter out filenames to keep based on player type
$regFilesPreserved = ($isTouch) ? "/^([0-9])+(_custom)?(?!(_fab4))+(\.jpg)+$/" : (($CUSTOM_IMAGE_COPIES) ? "/^([0-9])+(_fab4)?(?!(_custom))+(\.jpg)+$/" : "/^([0-9])+([_])?([fab4|custom])+(\.jpg)+$/");
$filesPreserved = preg_grep($regFilesPreserved, $directoryContents);
$files = array_diff($directoryContents, $filesPreserved);
if ($GRUVI_LOGO) {
	$regFilesPreserved = "/^(gruvi_logo)+([_fab4|_custom])*(\.jpg)+$/";
	$filesPreserved = preg_grep($regFilesPreserved, $directoryContents);
	$files = array_diff($files, $filesPreserved);
}
//Filter out annoying Windows Thumbs.db and nix dot directories
$isThumb = basename(realpath($IMAGE_ROOT . "Thumbs.db"));
$files = array_diff($files, array('.', '..', $isThumb, $BEGIN_NAME, "gruvi.lock"));
//Delete the rest, but the preserved files
foreach ($files as $file) {
	if (!in_array($file, $newFileNames)) {
		$file_path = $IMAGE_ROOT . $file;
		if (is_file($file_path)) {
			@unlink($file_path);
		}
	}
}

//Check if the local optimized copies of images exist or must be created
//OR if they are too old and must be replaced with new images
if (!$ALL) $fileArray = array();  //Array of files which should be updated or created
$gruviCounts = 0; $firstNewFile = 0; $gruviLogoCreated = False;
$fp = fopen($IMAGE_ROOT . $BEGIN_NAME, 'w');
clearstatcache();	//clear the cache for the @filemtime check file age function
//Prefill folder with the eventual number of files with faster copies of the GRUVI logo while waiting for images to convert
for ($i = 1; $i <= ($LIST_SIZE); $i++) {
	//Find missing files
	if (!file_exists("{$IMAGE_ROOT}{$i}{$FILE_SUFFIX}")) {
		$gruviCounts++;
		if (!$ALL) {
			$fileArray[] = $i;
			if ($gruviCounts == 1) {
				fwrite($fp, $IMAGEMAGICK . ' -background \'#0005\' -fill white -gravity center -size ' . escapeshellarg($X_WIDTH) . 'x' . escapeshellarg($Y_HEIGHT) . ' -pointsize  60 caption:GRUVI ' . escapeshellarg($IMAGE_ROOT) . $i . escapeshellarg($FILE_SUFFIX) . "\n");
				$firstNewFile = $i;
			}elseif ($gruviCounts > 1) {
				fwrite($fp, ($WINDOWS ? "copy " : "cp ") . "{$IMAGE_ROOT}{$firstNewFile}{$FILE_SUFFIX} {$IMAGE_ROOT}{$i}{$FILE_SUFFIX}\n");
			}
		}
	//Find files that need to be updated based on age
	}elseif ((time() - @filemtime("{$IMAGE_ROOT}{$i}{$FILE_SUFFIX}"))/60 > $FILE_AGE_MAX) {
		if (!$ALL) $fileArray[] = $i;
	}
}
//Create the GRUVI logo image file if so specified
if ($GRUVI_LOGO && !file_exists("{$IMAGE_ROOT}gruvi_logo{$FILE_SUFFIX}")) {
	if ($gruviCounts > 0 && !$ALL) {
		fwrite($fp, ($WINDOWS ? "copy " : "cp ") . "{$IMAGE_ROOT}{$firstNewFile}{$FILE_SUFFIX} {$IMAGE_ROOT}gruvi_logo{$FILE_SUFFIX}\n");
	}else {
		fwrite($fp, $IMAGEMAGICK . ' -background \'#0005\' -fill white -gravity center -size ' . escapeshellarg($X_WIDTH) . 'x' . escapeshellarg($Y_HEIGHT) . ' -pointsize  60 caption:GRUVI ' . escapeshellarg($IMAGE_ROOT) . 'gruvi_logo' . escapeshellarg($FILE_SUFFIX) . "\n");
	}
	$gruviLogoCreated = True;
	$gruviCounts++;
}
ConvertImages($fp);

//Print a summary of the file operations completed
if (PHP_SAPI === 'cli') {
	echo PHP_EOL . "FILE OPERATIONS:" . PHP_EOL;
	$directoryContents = array_diff($directoryContents, array('.', '..', $BEGIN_NAME, "gruvi.lock"));
	echo "files in dir: " . count($directoryContents) . PHP_EOL;
	$filesDeleted = max(0, count($files) - count($newFileNames));
	echo "files deleted: " . $filesDeleted . PHP_EOL;
	echo "files new: " . $gruviCounts . PHP_EOL;
	echo "files updated: " . ($gruviLogoCreated ? count($fileArray) + 1 - $gruviCounts : count($fileArray) - $gruviCounts) . PHP_EOL;
	echo "files converted: " . count($fileArray) . PHP_EOL;
}


link_to_originals3:
//Update the file for the players with the URL list for the Image Viewer applet to read
$indexList = array();
for ($i = 1; $i <=  $LIST_SIZE; $i++) {
	$indexList[] = $i;
}
if ($RANDOMIZE) shuffle($indexList); //For random image viewer starts
$fp = fopen($FILE_NAME, 'w');
if (!$LINK_TO_ORIGINALS) {
	if ($GRUVI_LOGO) {
		fwrite($fp, ($WEBLIST ? $URL_ROOT . $IMAGE_ROOT_UNMODIFIED . "/" : $IMAGE_ROOT) . "gruvi_logo" . $FILE_SUFFIX ."\n");
	}
	for ($i = 0; $i <=  $LIST_SIZE-1; $i++) {
		fwrite($fp, ($WEBLIST ? $URL_ROOT . $IMAGE_ROOT_UNMODIFIED . "/" : $IMAGE_ROOT) . $indexList[$i] . $FILE_SUFFIX ."\n");
	}
} else {
	if ($RANDOMIZE) shuffle($fileArray);
	foreach($fileArray as $file) fwrite($fp, $file . PHP_EOL);
}
fclose($fp);


//Send image URL file to Image Viewer via gruvi.php HTML output
//Flush output buffer to allow web server to show URL list before gruvi.php is finished
//Solution inspired by https://stackoverflow.com/a/14469376/12802435
if (PHP_SAPI === 'cli')	echo PHP_EOL . "IMAGE FILES LIST:" . PHP_EOL;
if (!($LINK_TO_ORIGINALS || $ALL)) usleep(500000);	//Introduce a slight delay to wait for file copy and avoid dead links
readfile($FILE_NAME);
if (ob_get_contents()) {
	ob_end_flush();
}
flush();
session_write_close();
if ($LINK_TO_ORIGINALS || $ALL) goto gruvi_exit;


link_to_originals1:
//Distribute weighted number of images pr. source by use of the Largest Remainder Method
$fileArraySize = ($LINK_TO_ORIGINALS) ? $LIST_SIZE : count($fileArray);
$sourceDist = array();
for ($i=0; $i<$noOfSources; $i++) {
	$sourceDist[] = floor($SOURCE_WEIGHT[$i]*$fileArraySize);
}
arsort($sourceDist);
$sourceSum = 0;
$index = array();
foreach ($sourceDist as $key => $val) {
	$index[] = $key;
	$sourceSum += $val;
}
$sourceDiff = $fileArraySize-$sourceSum;
for ($i=0; $i<$sourceDiff; $i++) {
	$sourceDist[$index[$i]] += 1;
}
if ($LINK_TO_ORIGINALS) {
	$fileArray = array();
	goto link_to_originals2;
}


//Start image and file operations if any images are missing or old
if (!$fileArraySize >=1) exit(0);

all1:
//Check if conversions from a previous run of gruvi.php is already running, exit to prevent system overload
//Solution borrowed from https://www.exakat.io/en/prevent-multiple-php-scripts-at-the-same-time/
$lockFolder = $IMAGE_ROOT . 'gruvi.lock';
if (@mkdir($lockFolder, 0700)) {
}else {
	exit("Did not suceed in creating the gruvi.lock folder.\nGRUVI already running?");
}


//Start image files processing
//If parallel conversion not allowed, open file once here
if (!$PARALLEL_CONVERT) $fp = fopen ($IMAGE_ROOT . $BEGIN_NAME, 'w+');

link_to_originals2:
//Figure out regex from IMAGE FORMAT SETTINGS
$formatArray = array($BMP, $CR2, $GIF, $HEIC, $JPEG, $PNG, $TIFF, $WEBP);
$regExpression = '/^(?!._).+'; $counter = 0;
foreach($formatArray as $index => $supported) {
	if ($supported) {
		if ($counter >= 1) $regExpression .= '|';
		switch ($index) {
			case 0: $regExpression .= '(.bmp)'; break;
			case 1: $regExpression .= '(.cr2)'; break;
			case 2: $regExpression .= '(.gif)'; break;
			case 3: $regExpression .= '(.hei[cf])'; break;
			case 4: $regExpression .= '(.jpe?g)'; break;
			case 5: $regExpression .= '(.png)'; break;
			case 6: $regExpression .= '(.tif?f)'; break;
			case 7: $regExpression .= '(.webp)'; break;
		}
		$counter++;
	}
}
$regExpression .= '$/i';


//For each image folder that needs processing...
$fileNameIndex = 0; $quickAll = 1;
if ($ALL) $fileArray = array();
for ($x = 0; $x < $noOfSources; $x++) {

	//Traverse directory and subdirectories recursively and populate array with filenames
	if (!$ALL) $fileArraySize = $sourceDist[$x];
	$fileNameArray = array();
	$flags = FilesystemIterator::SKIP_DOTS | FilesystemIterator::FOLLOW_SYMLINKS;
	$Directory = new RecursiveDirectoryIterator($IMG_SOURCE[$x], $flags);
	$Iterator = new RecursiveIteratorIterator($Directory, RecursiveIteratorIterator::LEAVES_ONLY);
	$Regex = new RegexIterator($Iterator, $regExpression, RecursiveRegexIterator::MATCH, RegexIterator::USE_KEY);
	$Regex->rewind();

	//Exclude images already converted in a gruvi_img/$IMG_ROOT folder
	foreach($Regex as $name) {
		if (strpos($name, $IMAGE_ROOT) !== 0) array_push($fileNameArray, $name);
	}

	//If all files found is wanted and number of image files is determined a posteriori by the folder traversal,
	//populate the gruvi_img folder first with faster copies of the GRUVI logo while waiting for later image conversions
	if ($ALL) $fileArraySize = count($fileNameArray);
	if ($ALL && !$LINK_TO_ORIGINALS) {
		if ($fileArraySize > 0) {
			$fill = "_fill" . $x;
			$fp2 = fopen($IMAGE_ROOT . $BEGIN_NAME . $fill, 'w');
			$firstNewFile = 0;
			for ($i = 0; $i < $fileArraySize; $i++) {
				if ($i == 0) {
					fwrite($fp2, $IMAGEMAGICK . ' -background \'#0005\' -fill white -gravity center -size ' . escapeshellarg($X_WIDTH) . 'x' . escapeshellarg($Y_HEIGHT) . ' -pointsize  60 caption:GRUVI ' . escapeshellarg($IMAGE_ROOT) . $quickAll . escapeshellarg($FILE_SUFFIX) . "\n");
					$firstNewFile = $quickAll;
				}elseif ($i > 0) {
					fwrite($fp2, ($WINDOWS ? "copy " : "cp ") . "{$IMAGE_ROOT}{$firstNewFile}{$FILE_SUFFIX} {$IMAGE_ROOT}{$quickAll}{$FILE_SUFFIX}\n");
				}
				$quickAll++;
			}
			ConvertImages($fp2, $WINDOWS, $fill);
		}
	}

	//Shuffle the array, and generate and run shell script to extract and resize the needed number of random new image files
	IF ($RANDOMIZE) shuffle($fileNameArray);

	//If parallel conversion allowed, open file for every image folder
	if ($PARALLEL_CONVERT && !$LINK_TO_ORIGINALS) {
		$fp = fopen ($IMAGE_ROOT . $BEGIN_NAME . $x, 'w');
	}

	//For each image file that needs processing in each folder...
	for ($i = 0; $i <= $fileArraySize - 1; $i++) {

		//Add to the fileArray array to determine the list size a posteriori by the number of images actually found
		if ($ALL && !$LINK_TO_ORIGINALS) array_push($fileArray, $fileNameIndex + 1);

		//Get caption text from filename and the name of the folder that the image file is stored in
		$exploded = ($WINDOWS) ? explode("\\", realpath($fileNameArray[$i])) : explode("/", realpath($fileNameArray[$i]));
		$event = $exploded[count($exploded)-2]; //Makes parent directory available as string for caption text
		$fileName = $exploded[count($exploded)-1];  //Makes file name available as string for caption text

		//If making copies, convert the original images files to the desired size
		if (!$LINK_TO_ORIGINALS) {
			if ($WINDOWS) {
				$captionArgs = ($CAPTIONS) ? '-background "#0005" -fill white -gravity west -size "' . $X_WIDTH . 'x' . $C_HEIGHT . '" -pointsize "' . $P_SIZE . '" caption:"' . $fileName . '\n' . $event . '" -gravity south -composite ' : '';
				fwrite($fp, $IMAGEMAGICK . ' "' . $fileNameArray[$i] . '" -auto-orient -background none -resize "' . $X_WIDTH . 'x' . $X_WIDTH . '" -gravity center -extent "' . $X_WIDTH . 'x' . $Y_HEIGHT . '" ' . $captionArgs . '"' . $IMAGE_ROOT . $fileArray[$fileNameIndex] . $FILE_SUFFIX . '"' . PHP_EOL);
			}else {
				$captionArgs = ($CAPTIONS) ? '\\( -background \'#0005\' -fill white -gravity west -size \'' . $X_WIDTH . 'x' . $C_HEIGHT . '\' -pointsize \'' . $P_SIZE . '\' caption:\'' . $fileName . '\n' . $event . '\' \\) -gravity south -composite ' : '';
				fwrite($fp, $IMAGEMAGICK . ' \\( \'' . $fileNameArray[$i] . '\' -auto-orient -background none -resize \'' . $X_WIDTH . 'x' . $X_WIDTH . '\' -gravity center -extent \'' . $X_WIDTH . 'x' . $Y_HEIGHT . '\' \\) ' . $captionArgs . '\'' . $IMAGE_ROOT . $fileArray[$fileNameIndex] . $FILE_SUFFIX . '\'' . PHP_EOL);
			}
		//If linking to the original image files directly, produce an array with the filepaths or URLs
		}else {
			if(!$WEBLIST) {
				array_push($fileArray, realpath($fileNameArray[$i]));
			}else {
				$subString = rtrim(realpath($IMG_SOURCE[$x]), DIRECTORY_SEPARATOR);
				if (getcwd() != realpath($IMG_SOURCE[$x])) {
					array_push($fileArray, $URL_ROOT . str_replace(" ", "%20", str_replace("\\", "/", str_replace(substr($subString , 0, strrpos($subString, DIRECTORY_SEPARATOR)+1), '', realpath($fileNameArray[$i])))));
				}else {
					array_push($fileArray, rtrim($URL_ROOT, "/") . str_replace(" ", "%20", str_replace("\\", "/", str_replace($subString, '', realpath($fileNameArray[$i])))));
				}
			}
		}

		//Early break out of loop if there are fewer images in the $IMG_SOURCE folder than expected from the weighted distribution between
		//the folders according to $SOURCE_WEIGHT. Fixes an earlier out-of-bounds bug when this was true.
		if ($i >= ($ALL ? count($fileNameArray) : count($fileNameArray) - 1)) {
			$fileNameIndex++;
			break;
		}else {
			if ($fileNameIndex < count($fileArray)) $fileNameIndex++;
		}
	}

	//If parallel conversion is allowed, process each folder immediately
	if ($PARALLEL_CONVERT && !$LINK_TO_ORIGINALS) ConvertImages($fp, $WINDOWS, $x);
}


//If parallel conversion is not allowed, process serially when all folders are finished set up
if (!$PARALLEL_CONVERT && !$LINK_TO_ORIGINALS) ConvertImages($fp, $WINDOWS);

if ($LINK_TO_ORIGINALS) goto link_to_originals3;  //Part of alternate control flow when linking to originals instead of converting files

if ($ALL) goto all2;	//Part of alternate control flow when list size during conversions is determined a posterior by image files
						//actually found in lieu of a priori set by the $LIST_SIZE setting

//Clean up before exiting
gruvi_exit:
//Remove lock folder
if (is_dir($lockFolder)) rmdir($lockFolder);

?>
